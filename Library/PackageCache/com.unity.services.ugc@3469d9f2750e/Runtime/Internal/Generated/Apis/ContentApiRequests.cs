//-----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by the C# SDK Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.Scripting;
using Unity.Services.Ugc.Generated.Models;
using Unity.Services.Ugc.Generated.Scheduler;
using Unity.Services.Ugc.Generated.Http;
using Unity.Services.Authentication.Internal;

namespace Unity.Services.Ugc.Generated.Content
{
    internal static class JsonSerialization
    {
        public static byte[] Serialize<T>(T obj)
        {
            return Encoding.UTF8.GetBytes(SerializeToString(obj));
        }

        public static string SerializeToString<T>(T obj)
        {
            return IsolatedJsonConvert.SerializeObject(obj, new JsonSerializerSettings{ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore});
        }
    }

    /// <summary>
    /// ContentApiBaseRequest class
    /// </summary>
    [Preserve]
    internal class ContentApiBaseRequest
    {
        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>` with the `key` and `value` added to the provided `queryParams`.</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, string value)
        {
            key = UnityWebRequest.EscapeURL(key);
            value = UnityWebRequest.EscapeURL(value);
            queryParams.Add($"{key}={value}");

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and list of values to the
        /// provided query params and to escape the values correctly if it is a
        /// URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="values">List of values to be added.</param>
        /// <param name="style">string for defining the style, currently unused.</param>
        /// <param name="explode">True if query params should be escaped and added separately.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, List<string> values, string style, bool explode)
        {
            if (explode)
            {
                foreach(var value in values)
                {
                    string escapedValue = UnityWebRequest.EscapeURL(value);
                    queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
                }
            }
            else
            {
                string paramString = $"{UnityWebRequest.EscapeURL(key)}=";
                foreach(var value in values)
                {
                    paramString += UnityWebRequest.EscapeURL(value) + ",";
                }
                paramString = paramString.Remove(paramString.Length - 1);
                queryParams.Add(paramString);
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided map of keys and values, representing a model, to the
        /// provided query params.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="modelVars">A `Dictionary` representing the vars of the model</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, Dictionary<string, string> modelVars)
        {
            foreach(var key in modelVars.Keys)
            {
                string escapedValue = UnityWebRequest.EscapeURL(modelVars[key]);
                queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <typeparam name="T">The type of the value to be added.</typeparam>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams<T>(List<string> queryParams, string key, T value)
        {
            if (queryParams == null)
            {
                queryParams = new List<string>();
            }

            key = UnityWebRequest.EscapeURL(key);
            string valueString = UnityWebRequest.EscapeURL(value.ToString());
            queryParams.Add($"{key}={valueString}");
            return queryParams;
        }

        /// <summary>
        /// Constructs a string representing an array path parameter.
        /// </summary>
        /// <param name="pathParam">The list of values to convert to string.</param>
        /// <returns>String representing the param.</returns>
        [Preserve]
        public string GetPathParamString(List<string> pathParam)
        {
            string paramString = "";
            foreach(var value in pathParam)
            {
                paramString += UnityWebRequest.EscapeURL(value) + ",";
            }
            paramString = paramString.Remove(paramString.Length - 1);
            return paramString;
        }

        /// <summary>
        /// Constructs the body of the request based on IO stream.
        /// </summary>
        /// <param name="stream">The IO stream to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(System.IO.Stream stream)
        {
            if (stream != null)
            {
                using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                {
                    stream.CopyTo(ms);
                    return ms.ToArray();
                }
            }
            return null;
        }

        /// <summary>
        /// Construct the request body based on string value.
        /// </summary>
        /// <param name="s">The input body.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(string s)
        {
            return System.Text.Encoding.UTF8.GetBytes(s);
        }

        /// <summary>
        /// Construct request body based on generic object.
        /// </summary>
        /// <param name="o">The object to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(object o)
        {
            return JsonSerialization.Serialize(o);
        }

        /// <summary>
        /// Generate an accept header.
        /// </summary>
        /// <param name="accepts">list of accepts objects.</param>
        /// <returns>The generated accept header.</returns>
        public string GenerateAcceptHeader(string[] accepts)
        {
            if (accepts.Length == 0)
            {
                return null;
            }
            for (int i = 0; i < accepts.Length; ++i)
            {
                if (string.Equals(accepts[i], "application/json", System.StringComparison.OrdinalIgnoreCase))
                {
                    return "application/json";
                }
            }
            return string.Join(", ", accepts);
        }

        private static readonly Regex JsonRegex = new Regex(@"application\/json(;\s)?((charset=utf8|q=[0-1]\.\d)(\s)?)*");

        /// <summary>
        /// Generate Content Type Header.
        /// </summary>
        /// <param name="contentTypes">The content types.</param>
        /// <returns>The Content Type Header.</returns>
        public string GenerateContentTypeHeader(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
            {
                return null;
            }

            for(int i = 0; i < contentTypes.Length; ++i)
            {
                if (!string.IsNullOrWhiteSpace(contentTypes[i]) && JsonRegex.IsMatch(contentTypes[i]))
                {
                    return contentTypes[i];
                }
            }
            return contentTypes[0];
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The file stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.FileStream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), GetFileName(stream.Name), contentType);
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The IO stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.Stream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), Guid.NewGuid().ToString(), contentType);
        }

        private string GetFileName(string filePath)
        {
            return System.IO.Path.GetFileName(filePath);
        }
    }

    /// <summary>
    /// CreateContentRequest
    /// Create new content item
    /// </summary>
    [Preserve]
    internal class CreateContentRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for newContentRequest </summary>
        [Preserve]
        public Unity.Services.Ugc.Generated.Models.NewContentRequest NewContentRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// CreateContent Request Object.
        /// Create new content item
        /// </summary>
        /// <param name="projectId">Project that this content belongs to</param>
        /// <param name="environmentId">Environment that this content belongs to</param>
        /// <param name="newContentRequest">Request information for content</param>
        [Preserve]
        public CreateContentRequest(string projectId, string environmentId, Unity.Services.Ugc.Generated.Models.NewContentRequest newContentRequest = default(Unity.Services.Ugc.Generated.Models.NewContentRequest))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            NewContentRequest = newContentRequest;
            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(NewContentRequest != null)
            {
                return ConstructBody(NewContentRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json",
                "text/json",
                "application/*+json"
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// CreateContentVersionRequest
    /// Creates a new version of the content item asset and image
    /// </summary>
    [Preserve]
    internal class CreateContentVersionRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for contentId </summary>
        [Preserve]
        public string ContentId { get; }
        /// <summary>Accessor for addVersionRequest </summary>
        [Preserve]
        public Unity.Services.Ugc.Generated.Models.AddVersionRequest AddVersionRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// CreateContentVersion Request Object.
        /// Creates a new version of the content item asset and image
        /// </summary>
        /// <param name="projectId">Project that this content belongs to</param>
        /// <param name="environmentId">Environment that this content belongs to</param>
        /// <param name="contentId">Content id</param>
        /// <param name="addVersionRequest">The AddVersionRequest request sent by the client</param>
        [Preserve]
        public CreateContentVersionRequest(string projectId, string environmentId, string contentId, Unity.Services.Ugc.Generated.Models.AddVersionRequest addVersionRequest = default(Unity.Services.Ugc.Generated.Models.AddVersionRequest))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            ContentId = contentId;

            AddVersionRequest = addVersionRequest;
            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/{contentId}/version";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(AddVersionRequest != null)
            {
                return ConstructBody(AddVersionRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json",
                "text/json",
                "application/*+json"
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// CreateUserRatingRequest
    /// Add a new user rating for content
    /// </summary>
    [Preserve]
    internal class CreateUserRatingRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for contentId </summary>
        [Preserve]
        public string ContentId { get; }
        /// <summary>Accessor for contentRatingRequest </summary>
        [Preserve]
        public Unity.Services.Ugc.Generated.Models.ContentRatingRequest ContentRatingRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// CreateUserRating Request Object.
        /// Add a new user rating for content
        /// </summary>
        /// <param name="projectId">Project that this content belongs to</param>
        /// <param name="environmentId">Environment that this content belongs to</param>
        /// <param name="contentId">Content id</param>
        /// <param name="contentRatingRequest">Request information for content rating</param>
        [Preserve]
        public CreateUserRatingRequest(string projectId, string environmentId, string contentId, Unity.Services.Ugc.Generated.Models.ContentRatingRequest contentRatingRequest = default(Unity.Services.Ugc.Generated.Models.ContentRatingRequest))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            ContentId = contentId;

            ContentRatingRequest = contentRatingRequest;
            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/{contentId}/rating";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(ContentRatingRequest != null)
            {
                return ConstructBody(ContentRatingRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json",
                "text/json",
                "application/*+json"
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "PUT";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// DeleteContentRequest
    /// Soft delete a content item
    /// </summary>
    [Preserve]
    internal class DeleteContentRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for contentId </summary>
        [Preserve]
        public string ContentId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// DeleteContent Request Object.
        /// Soft delete a content item
        /// </summary>
        /// <param name="projectId">Project that this content belongs to</param>
        /// <param name="environmentId">Environment that this content belongs to</param>
        /// <param name="contentId">Content id</param>
        [Preserve]
        public DeleteContentRequest(string projectId, string environmentId, string contentId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            ContentId = contentId;

            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/{contentId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetContentRequest
    /// Get details about a content item
    /// </summary>
    [Preserve]
    internal class GetContentRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for contentId </summary>
        [Preserve]
        public string ContentId { get; }
        /// <summary>Accessor for includeStatistics </summary>
        [Preserve]
        public bool? IncludeStatistics { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetContent Request Object.
        /// Get details about a content item
        /// </summary>
        /// <param name="projectId">Project that this content belongs to</param>
        /// <param name="environmentId">Environment that this content belongs to</param>
        /// <param name="contentId">Content id</param>
        /// <param name="includeStatistics">If content stats should be included in the query</param>
        [Preserve]
        public GetContentRequest(string projectId, string environmentId, string contentId, bool? includeStatistics = false)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            ContentId = contentId;

            IncludeStatistics = includeStatistics;
            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/{contentId}";

            List<string> queryParams = new List<string>();

            var includeStatisticsStringValue = IncludeStatistics.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "includeStatistics", includeStatisticsStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetContentDownloadsRequest
    /// Get content statistics
    /// </summary>
    [Preserve]
    internal class GetContentDownloadsRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for contentId </summary>
        [Preserve]
        public string ContentId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetContentDownloads Request Object.
        /// Get content statistics
        /// </summary>
        /// <param name="projectId">Project that this content belongs to</param>
        /// <param name="environmentId">Environment that this content belongs to</param>
        /// <param name="contentId">Content id</param>
        [Preserve]
        public GetContentDownloadsRequest(string projectId, string environmentId, string contentId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            ContentId = contentId;

            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/{contentId}/downloads";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetContentTrendsListRequest
    /// Get content trends
    /// </summary>
    [Preserve]
    internal class GetContentTrendsListRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for trendType </summary>
        [Preserve]
        public string TrendType { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        /// <summary>Accessor for sortBy </summary>
        [Preserve]
        public string SortBy { get; }
        /// <summary>Accessor for includeTotal </summary>
        [Preserve]
        public bool? IncludeTotal { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetContentTrendsList Request Object.
        /// Get content trends
        /// </summary>
        /// <param name="projectId">Project to query content trends</param>
        /// <param name="environmentId">Environment to query content trends</param>
        /// <param name="trendType">Trend type: TopRated, MostDownloaded, Newest, Popular, Trending, Engaging</param>
        /// <param name="offset">The amount of results to skip</param>
        /// <param name="limit">The amount of results to take</param>
        /// <param name="sortBy">The field to use to sort by in order, prefix - for descending</param>
        /// <param name="includeTotal">Should the result include the total count of objects available to page</param>
        [Preserve]
        public GetContentTrendsListRequest(string projectId, string environmentId, string trendType, int? offset = default(int?), int? limit = default(int?), string sortBy = default(string), bool? includeTotal = default(bool?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            TrendType = trendType;

            Offset = offset;
            Limit = limit;
            SortBy = sortBy;
            IncludeTotal = includeTotal;
            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/trends/{trendType}";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if(!string.IsNullOrEmpty(SortBy))
            {
                queryParams = AddParamsToQueryParams(queryParams, "sortBy", SortBy);
            }
            var includeTotalStringValue = IncludeTotal.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "includeTotal", includeTotalStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetUserRatingRequest
    /// Get content rating for user
    /// </summary>
    [Preserve]
    internal class GetUserRatingRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for contentId </summary>
        [Preserve]
        public string ContentId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetUserRating Request Object.
        /// Get content rating for user
        /// </summary>
        /// <param name="projectId">Project that this content belongs to</param>
        /// <param name="environmentId">Environment that this content belongs to</param>
        /// <param name="contentId">Content id</param>
        [Preserve]
        public GetUserRatingRequest(string projectId, string environmentId, string contentId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            ContentId = contentId;

            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/{contentId}/rating";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// SearchContentRequest
    /// Search all content items in a given project and environment
    /// </summary>
    [Preserve]
    internal class SearchContentRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        /// <summary>Accessor for sortBys </summary>
        [Preserve]
        public List<string> SortBys { get; }
        /// <summary>Accessor for search </summary>
        [Preserve]
        public string Search { get; }
        /// <summary>Accessor for tags </summary>
        [Preserve]
        public List<string> Tags { get; }
        /// <summary>Accessor for filters </summary>
        [Preserve]
        public List<string> Filters { get; }
        /// <summary>Accessor for includeTotal </summary>
        [Preserve]
        public bool? IncludeTotal { get; }
        /// <summary>Accessor for includeStatistics </summary>
        [Preserve]
        public bool? IncludeStatistics { get; }
        string PathAndQueryParams;

        /// <summary>
        /// SearchContent Request Object.
        /// Search all content items in a given project and environment
        /// </summary>
        /// <param name="projectId">Content that belongs to this project</param>
        /// <param name="environmentId">Content that belongs to this environment</param>
        /// <param name="offset">The amount of results to skip</param>
        /// <param name="limit">The amount of results to take</param>
        /// <param name="sortBys">The field to use to sort by in ascending order, prefix - for descending</param>
        /// <param name="search">Only return results with this search term in their name</param>
        /// <param name="tags">Only return results with these tags</param>
        /// <param name="filters">You can filter on any field in the DTO<br />  Syntax for filters is: {field},{operator},{value}<br />  The operators are: eq (equal to), neq (not equal to), gt (greater than), gte (greater than or equal), lt (less than), lte (less than or equal)<br />  The field can be nested up to two levels. Ex: \"field.nestedField.nestedNestedField\"<br />  filters=\"deletedAt,eq,null\" will only return entities that have not been deleted<br /></param>
        /// <param name="includeTotal">Should the result include the total count of objects available to page</param>
        /// <param name="includeStatistics">If content stats should be included in the content DTO</param>
        [Preserve]
        public SearchContentRequest(string projectId, string environmentId, int? offset = default(int?), int? limit = default(int?), List<string> sortBys = default(List<string>), string search = default(string), List<string> tags = default(List<string>), List<string> filters = default(List<string>), bool? includeTotal = default(bool?), bool? includeStatistics = false)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            Offset = offset;
            Limit = limit;
            SortBys = sortBys;
            Search = search;
            Tags = tags;
            Filters = filters;
            IncludeTotal = includeTotal;
            IncludeStatistics = includeStatistics;
            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/search";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if(SortBys != null)
            {
                var sortBysStringValues = SortBys.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "sortBys", sortBysStringValues, "form", true);
            }
            if(!string.IsNullOrEmpty(Search))
            {
                queryParams = AddParamsToQueryParams(queryParams, "search", Search);
            }
            if(Tags != null)
            {
                var tagsStringValues = Tags.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "tags", tagsStringValues, "form", true);
            }
            if(Filters != null)
            {
                var filtersStringValues = Filters.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "filters", filtersStringValues, "form", true);
            }
            var includeTotalStringValue = IncludeTotal.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "includeTotal", includeTotalStringValue);
            var includeStatisticsStringValue = IncludeStatistics.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "includeStatistics", includeStatisticsStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// SearchPlayerContentRequest
    /// Search all player content items
    /// </summary>
    [Preserve]
    internal class SearchPlayerContentRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        /// <summary>Accessor for sortBys </summary>
        [Preserve]
        public List<string> SortBys { get; }
        /// <summary>Accessor for search </summary>
        [Preserve]
        public string Search { get; }
        /// <summary>Accessor for filters </summary>
        [Preserve]
        public List<string> Filters { get; }
        /// <summary>Accessor for includeTotal </summary>
        [Preserve]
        public bool? IncludeTotal { get; }
        /// <summary>Accessor for includeStatistics </summary>
        [Preserve]
        public bool? IncludeStatistics { get; }
        string PathAndQueryParams;

        /// <summary>
        /// SearchPlayerContent Request Object.
        /// Search all player content items
        /// </summary>
        /// <param name="offset">The amount of results to skip</param>
        /// <param name="limit">The amount of results to take</param>
        /// <param name="sortBys">The field to use to sort by in ascending order, prefix - for descending</param>
        /// <param name="search">Only return results with this search term in their name</param>
        /// <param name="filters">You can filter on any field in the DTO<br />  Syntax for filters is: {field},{operator},{value}<br />  The operators are: eq (equal to), neq (not equal to), gt (greater than), gte (greater than or equal), lt (less than), lte (less than or equal)<br />  The field can be nested up to two levels. Ex: \"field.nestedField.nestedNestedField\"<br />  filters=\"deletedAt,eq,null\" will only return entities that have not been deleted<br /></param>
        /// <param name="includeTotal">Should the result include the total count of objects available to page</param>
        /// <param name="includeStatistics">If content stats should be included in the content DTO</param>
        [Preserve]
        public SearchPlayerContentRequest(int? offset = default(int?), int? limit = default(int?), List<string> sortBys = default(List<string>), string search = default(string), List<string> filters = default(List<string>), bool? includeTotal = default(bool?), bool? includeStatistics = false)
        {
            Offset = offset;
            Limit = limit;
            SortBys = sortBys;
            Search = search;
            Filters = filters;
            IncludeTotal = includeTotal;
            IncludeStatistics = includeStatistics;
            PathAndQueryParams = $"/v1/content/search";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if(SortBys != null)
            {
                var sortBysStringValues = SortBys.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "sortBys", sortBysStringValues, "form", true);
            }
            if(!string.IsNullOrEmpty(Search))
            {
                queryParams = AddParamsToQueryParams(queryParams, "search", Search);
            }
            if(Filters != null)
            {
                var filtersStringValues = Filters.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "filters", filtersStringValues, "form", true);
            }
            var includeTotalStringValue = IncludeTotal.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "includeTotal", includeTotalStringValue);
            var includeStatisticsStringValue = IncludeStatistics.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "includeStatistics", includeStatisticsStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// UpdateContentVisibilityRequest
    /// Update content visibility
    /// </summary>
    [Preserve]
    internal class UpdateContentVisibilityRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for contentId </summary>
        [Preserve]
        public string ContentId { get; }
        /// <summary>Accessor for updateContentVisibilityRequestParameter </summary>
        [Preserve]
        public Unity.Services.Ugc.Generated.Models.UpdateContentVisibilityRequest UpdateContentVisibilityRequestParameter { get; }
        string PathAndQueryParams;

        /// <summary>
        /// UpdateContentVisibility Request Object.
        /// Update content visibility
        /// </summary>
        /// <param name="projectId">Project that this content belongs to</param>
        /// <param name="environmentId">Environment that this content belongs to</param>
        /// <param name="contentId">Content id</param>
        /// <param name="updateContentVisibilityRequestParameter">Request information for content</param>
        [Preserve]
        public UpdateContentVisibilityRequest(string projectId, string environmentId, string contentId, Unity.Services.Ugc.Generated.Models.UpdateContentVisibilityRequest updateContentVisibilityRequestParameter = default(Unity.Services.Ugc.Generated.Models.UpdateContentVisibilityRequest))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            ContentId = contentId;

            UpdateContentVisibilityRequestParameter = updateContentVisibilityRequestParameter;
            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/{contentId}/visibility";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(UpdateContentVisibilityRequestParameter != null)
            {
                return ConstructBody(UpdateContentVisibilityRequestParameter);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json",
                "text/json",
                "application/*+json"
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "PUT";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// UpdateDetailsRequest
    /// Update details about a content item
    /// </summary>
    [Preserve]
    internal class UpdateDetailsRequest : ContentApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public string EnvironmentId { get; }
        /// <summary>Accessor for contentId </summary>
        [Preserve]
        public string ContentId { get; }
        /// <summary>Accessor for updateContentRequest </summary>
        [Preserve]
        public Unity.Services.Ugc.Generated.Models.UpdateContentRequest UpdateContentRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// UpdateDetails Request Object.
        /// Update details about a content item
        /// </summary>
        /// <param name="projectId">Project that this content belongs to</param>
        /// <param name="environmentId">Environment that this content belongs to</param>
        /// <param name="contentId">Content id</param>
        /// <param name="updateContentRequest">Request information for content</param>
        [Preserve]
        public UpdateDetailsRequest(string projectId, string environmentId, string contentId, Unity.Services.Ugc.Generated.Models.UpdateContentRequest updateContentRequest = default(Unity.Services.Ugc.Generated.Models.UpdateContentRequest))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            ContentId = contentId;

            UpdateContentRequest = updateContentRequest;
            PathAndQueryParams = $"/v1/projects/{projectId}/environments/{environmentId}/content/{contentId}/details";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(UpdateContentRequest != null)
            {
                return ConstructBody(UpdateContentRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json",
                "text/json",
                "application/*+json"
            };

            string[] accepts = {
                "application/json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "PUT";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
}
